[ORG 0x00]  ;ORG 0x00 : 코드의 시작 어드레스를 0x00 으로 설정
[BITS 16]   ;BITS 16  : 이하의 코드는 16 비트 코드로 설정


SECTION .text  ;SECTION .text : text 섹션(세그먼트) 을 정의


jmp 0x07c0:START ; CS 세그먼트 레지스터에 0x07C0 을 복사하면서 START 레이블로 이동

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MINT64 OS 에 관련된 환경 설정 값
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TOTALSECTORCOUNT: dw 1024  ; 부트 로더를 제외한 MINT64 OS 이미지 크기


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 코드영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
	mov ax, 0x07C0 ; 부트 로더의 시가 어드레스 (0x7C00)를 세그먼트 레지스터 값으로 변환
	mov ds, ax     ; DS 세그먼트 레지스터에 설정
	mov ax, 0xB800 ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환
	mov es, ax     ; ES 세그먼트 레지스터에 설정

	; 스택을 0x0000:0000 - 0x0000:FFFF 영역에 64KB 크기로 생성
	mov ax, 0x0000 ; 스택 세그먼트의 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환
	mov ss, ax     ; SS 세그먼트 레지스터에 설정
	mov sp, 0xFFFE ; SP 레지스터에 어드레스를 0xFFFE 로 설정
	mov bp, 0xFFFE ; BP 레지스터의 어드레스를 0xFFFE 로 설정


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 화면을 모두 지우고, 속성값을 녹생으로 설정
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov si, 0  ; SI 레지스터( 문자열 원본 인덱스 레지스터 ) 를 초기화

.SCREENCLEARLOOP:
	mov byte [es: si], 0 	      ; 비디오 메모리의 문자가 위치하는 어드레스에 0 을 복사하여 문자 삭제
	mov byte [es: si + 1], 0x0A   ; 비디오 메모리의 속성이 위치하는 어드레스에 0x0A( 검은 바탕에 밝은 녹색 ) 을 복사 
	; 메모리 접근은 암시적으로 DS 세그먼트 레지스터를 사용. 따라서 명시적으로 es 레지스터를 사용하기 위해서는 ex: 오프셋 으로 지정해야 한다.

	add si, 2                     ; 다음 위치로 이동

	cmp si, 80 * 25 * 2           ; 화면의 전체 크기는 80 문자 * 25 라인.
	jl .SCREENCLEARLOOP           ; 위의 cmp 문에서 SI 레지스터가 화면 크기보다 작다면 SCREENCLREALOOP 레이블로 이동.


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 화면 상단에 시작 메시지 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push MESSAGE1       ; 출력할 메시지의 어드레스를 스택에 삽입
	push 0              ; 화면 Y 좌표(0)를 스택에 삽입
	push 0              ; 화면 X 좌표(0)를 스택에 삽입
	call PRINTMESSAGE   ; PRINTMESSAGE 함수 호출
	add sp, 6           ; 삽입한 파라미터 제거. ( push 를 3 번했으므로 2 * 3 만큼을 되돌린다 )


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; OS 이미지를 로딩한다는 메시지 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push IMAGELOADINGMESSAGE
	push 1
	push 0
	call PRINTMESSAGE
	add sp, 6


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스크에서 OS 이미지를 로딩
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스크를 읽기 전에 먼저 리셋
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESETDISK:


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; BIOS Reset Function 호출
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 서비스 번호 0, 드라이브 번호 ( 0=Floppy )
	mov ax, 0
	mov dl, 0
	int 0x13   ; 에러가 발생하면 에러 처리로 이동
	jc HANDLEDISKERROR

	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스크에서 섹터를 읽음
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 디스크의 내용을 메모리로 복사할 어드레스 ( ES:BX ) 를 0x10000 으로 설정
	mov si, 0x1000   ;  OS 이미지를 복사할 어드레스(0x10000) 를 세그먼트 레지스터 값으로 변환
	mov es, si
	mov bx, 0x0000

	mov di, word [ TOTALSECTORCOUNT ]

READDATA:  ; 디스크를 읽는 코드의 시작
	; 모든 섹터를 다 읽었는지 확인
	cmp di, 0   ; 복사할 OS 이미지의 섹터 수를 0 과 비교
	je READEND	; 복사할 섹터 수가 0 이라면 다 복사 했으므로 READEND 로 이동
	sub di, 0x1	; 복사할 섹터 수를 1 감소


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
	; BIOS Read Function 호출
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov ah, 0x02
	mov al, 0x1
	mov ch, byte [ TRACKNUMBER ]
	mov cl, byte [ SECTORNUMBER ]
	mov dh, byte [ HEADNUMBER ]
	mov dl, 0x00
	int 0x13
	jc HANDLEDISKERROR


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 복사할 어드레스와 트랙, 헤드, 섹터 어드레스 계산
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	add si, 0x0020  ; 512(0x200) 바이트만큼 읽었으므로, 이를 세그먼트 레지스터 값으로 변환
	mov es, si      ; ES 세그먼트 레지스터에 더해서 어드레스를 한 섹터 만큼 증가

	; 한 섹터를 읽었으므로 섹터 번호를 증가시키고 마지막 섹터(18) 까지 읽었는지 판단.
	; 마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터 읽기 수행
	mov al, byte [ SECTORNUMBER ]
	add al, 0x01
	mov byte [ SECTORNUMBER ], al
	cmp al, 19
	jl READDATA

	; 마지막 섹터까지 읽었으면( 섹터 번호가 19 이면 ) 헤드를 토글 ( 0->1, 1-> 0 ) 하고 섹터 번호를 1 로 설정
	xor byte [ HEADNUMBER ], 0x01
	mov byte [ SECTORNUMBER ], 0x01

	
	; 만약 헤드가 1->0 로 바뀌었으면 양쪽 헤드를 모두 읽은 것이므로 아래로 이동하여 트랙 번호를 1 증가
	cmp byte [ HEADNUMBER ], 0x00
	jne READDATA					; if not

	; 트랙을 1 증가시킨 후 다시 섹터 읽기로 이동
	add byte [ TRACKNUMBER ], 0x01
	jmp READDATA

READEND:


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; OS 이미지가 완료되었다는 메시지를 출력
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	push LOADINGCOMPLETEMESSAGE
	push 1
	push 20
	call PRINTMESSAGE
	add sp, 6



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 함수 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 디스크 에러를 처리
HANDLEDISKERROR:
	push DISKERRORMESSAGE
	push 1
	push 20
	call PRINTMESSAGE

	jmp $


; 메시지를 출력 PARAM : x 좌표, y 좌표, 문자열
PRINTMESSAGE:
	push bp
	mov bp, sp

	push es
	push si
	push ax
	push cx
	push dx

	mov ax, 0xB800   ; 비디오 메모리 시작 어드레스 ( 0xB8000 ) 를 세그먼트 레지스터 값으로 변환
	mov es, ax
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; X, Y 의 좌표로 비디오 메모리의 어드레스를 계산함
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Y 좌표를 이용해서 먼저 라인 어드레스를 구함
	mov ax, word [ bp + 6 ]
	mov si, 160              ; 한 라인의 바이트 수 계산
	mul si
	mov di, ax

	; X 좌표를 이용해서 먼저 라인 어드레스를 구함
	mov ax, word [ bp + 4 ]
	mov si, 2               ; 한 문자를 나타내는 바이트 수 계산
	mul si
	mov di, ax

	; 출력할 문자열의 어드레스
	mov si, word [ bp + 8 ]


.MESSAGELOOP:
	mov cl, byte [ si ]

	cmp cl, 0
	je .MESSAGEEND

	mov byte [es: di], cl

	add si, 1
	add di, 2

	jmp .MESSAGELOOP

.MESSAGEEND:
	pop dx
	pop cx
	pop ax
	pop di
	pop si
	pop es
	pop bp
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 데이터 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 부트 로더 시작 메시지
	MESSAGE1: db 'MINT64 OS Boot Loader Start', 0

	DISKERRORMESSAGE: db 'DISK Error', 0
	IMAGELOADINGMESSAGE: db 'OS Image Loading...', 0
	LOADINGCOMPLETEMESSAGE: db 'Complete', 0

	; 디스크 읽이에 관련된 변수들
	SECTORNUMBER: db 0x02
	HEADNUMBER:   db 0x00
	TRACKNUMBER:  db 0x00


	times 510 - ( $ - $$ ) db 0x00 
	; $      : 현재 라인의 어드레스를 의미
	; $$     : 현재 어드레스가 포함된 섹션의 시작 어드레스
	; $ - $$ : 섹션의 시작을 기준으로 하는 오프셋
	; times  : times 명령 다음에 오는 횟수만큼 작업을 반복하라는 의미

	db 0x55 
	db 0xAA 			
	;db xx : Defind Byte 의 약자. 현재 어드레스에 1 바이트xx 를 삽입하라는 의미.
	;db 0x55, db 0xAA : 부트 로더임을 알리는 값 	
		


